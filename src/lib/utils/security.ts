export class SecurityUtils {\n  // XSS Protection\n  static sanitizeHtml(input: string): string {\n    const div = document.createElement('div');\n    div.textContent = input;\n    return div.innerHTML;\n  }\n\n  static escapeHtml(text: string): string {\n    const map: { [key: string]: string } = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#039;'\n    };\n    return text.replace(/[&<>\"']/g, (m) => map[m]);\n  }\n\n  // CSRF Protection\n  static generateCSRFToken(): string {\n    const array = new Uint8Array(32);\n    crypto.getRandomValues(array);\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n\n  static validateCSRFToken(token: string): boolean {\n    return token && token.length === 64 && /^[a-f0-9]+$/.test(token);\n  }\n\n  // Input Validation\n  static isValidInput(input: string, maxLength: number = 1000): boolean {\n    if (!input || typeof input !== 'string') {\n      return false;\n    }\n    \n    if (input.length > maxLength) {\n      return false;\n    }\n    \n    // Check for potentially malicious patterns\n    const maliciousPatterns = [\n      /<script[^>]*>.*?<\\/script>/gi,\n      /javascript:/gi,\n      /vbscript:/gi,\n      /on\\w+\\s*=/gi,\n      /<iframe[^>]*>.*?<\\/iframe>/gi,\n      /<object[^>]*>.*?<\\/object>/gi,\n      /<embed[^>]*>.*?<\\/embed>/gi\n    ];\n    \n    return !maliciousPatterns.some(pattern => pattern.test(input));\n  }\n\n  // URL Validation\n  static isValidUrl(url: string): boolean {\n    try {\n      const urlObj = new URL(url);\n      return ['http:', 'https:'].includes(urlObj.protocol);\n    } catch {\n      return false;\n    }\n  }\n\n  static isSafeRedirectUrl(url: string, allowedDomains: string[] = []): boolean {\n    try {\n      const urlObj = new URL(url, window.location.origin);\n      \n      // Allow relative URLs\n      if (urlObj.origin === window.location.origin) {\n        return true;\n      }\n      \n      // Check against allowed domains\n      return allowedDomains.some(domain => urlObj.hostname === domain || urlObj.hostname.endsWith('.' + domain));\n    } catch {\n      return false;\n    }\n  }\n\n  // Content Security\n  static stripScripts(html: string): string {\n    const div = document.createElement('div');\n    div.innerHTML = html;\n    \n    // Remove all script tags\n    const scripts = div.querySelectorAll('script');\n    scripts.forEach(script => script.remove());\n    \n    // Remove event handlers\n    const allElements = div.querySelectorAll('*');\n    allElements.forEach(element => {\n      Array.from(element.attributes).forEach(attr => {\n        if (attr.name.startsWith('on')) {\n          element.removeAttribute(attr.name);\n        }\n      });\n    });\n    \n    return div.innerHTML;\n  }\n\n  // Session Security\n  static isSessionExpired(timestamp: number, maxAge: number = 24 * 60 * 60 * 1000): boolean {\n    return Date.now() - timestamp > maxAge;\n  }\n\n  static secureStorage = {\n    setItem(key: string, value: string, encrypt: boolean = false): void {\n      try {\n        const data = encrypt ? btoa(value) : value;\n        localStorage.setItem(key, data);\n      } catch (error) {\n        console.error('Failed to store data securely:', error);\n      }\n    },\n\n    getItem(key: string, decrypt: boolean = false): string | null {\n      try {\n        const data = localStorage.getItem(key);\n        if (!data) return null;\n        return decrypt ? atob(data) : data;\n      } catch (error) {\n        console.error('Failed to retrieve data securely:', error);\n        return null;\n      }\n    },\n\n    removeItem(key: string): void {\n      try {\n        localStorage.removeItem(key);\n      } catch (error) {\n        console.error('Failed to remove data securely:', error);\n      }\n    }\n  };\n\n  // Password Security\n  static checkPasswordStrength(password: string): {\n    score: number;\n    feedback: string[];\n    isStrong: boolean;\n  } {\n    const feedback: string[] = [];\n    let score = 0;\n\n    if (password.length >= 8) {\n      score += 1;\n    } else {\n      feedback.push('Use at least 8 characters');\n    }\n\n    if (/[a-z]/.test(password)) {\n      score += 1;\n    } else {\n      feedback.push('Include lowercase letters');\n    }\n\n    if (/[A-Z]/.test(password)) {\n      score += 1;\n    } else {\n      feedback.push('Include uppercase letters');\n    }\n\n    if (/\\d/.test(password)) {\n      score += 1;\n    } else {\n      feedback.push('Include numbers');\n    }\n\n    if (/[^\\w\\s]/.test(password)) {\n      score += 1;\n    } else {\n      feedback.push('Include special characters');\n    }\n\n    if (password.length >= 12) {\n      score += 1;\n    }\n\n    return {\n      score,\n      feedback,\n      isStrong: score >= 4\n    };\n  }\n\n  // Rate Limiting (Client-side)\n  static rateLimiter = {\n    attempts: new Map<string, { count: number; resetTime: number }>(),\n    \n    isAllowed(key: string, maxAttempts: number = 5, windowMs: number = 15 * 60 * 1000): boolean {\n      const now = Date.now();\n      const record = this.attempts.get(key);\n      \n      if (!record || now > record.resetTime) {\n        this.attempts.set(key, { count: 1, resetTime: now + windowMs });\n        return true;\n      }\n      \n      if (record.count >= maxAttempts) {\n        return false;\n      }\n      \n      record.count++;\n      return true;\n    },\n    \n    reset(key: string): void {\n      this.attempts.delete(key);\n    }\n  };\n}